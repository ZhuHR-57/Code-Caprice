# 数组

## 二分查找

> 适合：**有序数组**
>
> **难点**：
>
> 1. 中间值等号部分的处理

```c
// [a , b] 左闭右闭
high = len(nums) - 1;
while(low <= high){ high = mid - 1 }

// [a , b) 左闭右开
high = len(nums);
while(low < high){ high = mid }
```

> 2. 防止溢出

```c
int middle = left + ((right - left) / 2);
```

> 3. 寻找相同元素的左右边界
>
> **难点**：若遇到相同元素后的位置判断
>
> + 判断是否是最左边的元素：
>   + 如果是0，则必然是最左边的元素
>   + 如果再往左移动一位则不是相同元素，也说明是最左的元素

```go
func getRightBorder(nums []int, target int) int {

    low,high := 0,len(nums)-1
    var mid int
   

    for low <= high {
        mid = low + ((high - low)/2)
        
        if nums[mid] == target{
            // 判断是否在最右边
            // 1. 如果是最右边元素，那肯定是最右边的
            // 2. 或者下一个元素不再是target，那也说明是最后一个元素
            if mid == len(nums) - 1 || nums[mid + 1] != target{
                return mid
            }else{
                low = mid + 1
            }
        }else if nums[mid] > target{
            high = mid - 1
        }else {
            low = mid + 1
        }
    }
    
    return -2
}
```

> 3. 开平方
>
> **难点**：mid == x/mid（这个比较难想到）

```go
func mySqrt(x int) int {
    
    if x == 0 || x == 1{
        return x
    }

    low,high := 0,x // 这里不能是x/2,因为可能会使mid = 0，出现分母为0异常
    var mid int

    for low <= high {
        mid = low + ((high - low)/2)
        if mid == x/mid{
            return mid
        }else if mid > x/mid{
            high = mid - 1
        }else{
            low = mid + 1
        }
    } 
    
    return high
}
```

$\sqrt{x}=x^{\frac{1}{2}}=e^{\frac{1}{2}lnx}$，算术运算法

```go
ans := int(math.Exp(0.5*math.Log(float64(x))))
if ans*ans == num || (ans+1)*(ans+1) == num{
    return true
}
```

## 双指针移动

> **双指针**方法实现O(n)删除元素
>
> 难点：理解fast和slow指针功能
>
> + fast指针，指向需要更新的元素（非Val）
>
> + low指针，用于统计和被更新

![Screenshot 2023-01-04 18.55.51](%E6%95%B0%E7%BB%84.assets/Screenshot%202023-01-04%2018.55.51.png)

### 双指针相邻元素是否重复

> 通过距离判断来删除重复的元素，**判断相邻元素是否重复**

```go
for fast,slow = 1,0; fast < numsLen; fast++ {

	if nums[slow] != nums[fast]{

		if fast - slow > 1 {
			nums[slow + 1] = nums[fast]
		}

		slow++
	} 
}
```

### 双指针移动元素

> 思路：
>
> 1. 若不等于0，则先fast覆盖slow
> 2. 若fast不等于slow，则将fast也覆盖为0
> 3. 最后让slow前进

```go
if nums[fast] != 0 {
	nums[slow] = nums[fast]
    
    if slow != fast {
        nums[fast] = 0
    }
    
    slow++
}
```

![Screenshot 2023-01-05 11.39.38](%E6%95%B0%E7%BB%84.assets/Screenshot%202023-01-05%2011.39.38.png)

### 双指针分别对比两个数组元素

> **难点：**
>
> 最后的边界判断
>
> 1. 都正的情况下可以比较当前元素
> 2. 都负的情况下，说明都遍历完了且相等
> 3. 一正一负，说明一个遍历完了一个没有遍历完，必然不相等

![Screenshot 2023-01-05 15.10.19](%E6%95%B0%E7%BB%84.assets/Screenshot%202023-01-05%2015.10.19.png)

### 双指针归并

![](https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif)

### 双指针滑动窗口

> `小坑：` res结果的初始设置和最后的判断

```go
func minSubArrayLen(target int, nums []int) int {

    numsLen,sum := len(nums),0
    res := numsLen + 1 //防止没有出现满足连续子数组和
    
    ...

    if res == numsLen + 1 {
        return 0
    }else{
        return res
    }
    
}
```

![](https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif)